@page "/products/AddProductType"
@inject ProductsService productsService
@inject ProductTypesService productTypesService
@inject IFileReaderService fileReaderService
@inject NavigationManager navigatorManager
@using System.IO;
@using System.Security.Claims;
@attribute [Authorize(Roles = "Admin")]

<h3>Добавить тип  продукта</h3>

<div class="row">
    <div class=" =col-6">

            <RadzenCard>
                <AlertMessage Message="@message" OnClickCallback="CloseInfoMessage" MessageType="@messageType" />
                @*<DataAnnotationsValidator />*@
               @* <ValidationSummary />*@
                @*//TODO: Сделать проверку на не заполненные поля выводить предупреждение *@
                <RadzenTextBox Placeholder="Наименование" @bind-Value="model.TypeName" Style="margin:10px;" />
                <hr />
                <RadzenButton ButtonType="Radzen.ButtonType.Submit" ButtonStyle="Radzen.ButtonStyle.Success" Click="async () => await addProductTypeAsync()" Text="Добавить типы продуктов"> </RadzenButton>
            </RadzenCard>

    </div>
</div>

@code {

    [CascadingParameter]
    private Task<AuthenticationState> authenticationState { get; set; }

    ProductType model = new ProductType();
    //System.IO.Stream fileStream = null;
    //string imageContent = string.Empty;
    //string fileName = string.Empty;


    bool isBusy = false;

    ElementReference inputReference;

    //Сообщения об ошибках
    string message = string.Empty;
    Models.AlertMessageType messageType = Models.AlertMessageType.Success;

    protected async override Task OnInitializedAsync()
    {
        //await getProductTypeAsync();
        base.OnInitializedAsync();
    }


    //async Task chooseFileAsync()
    //{
    //    var file = (await fileReaderService.CreateReference(inputReference).EnumerateFilesAsync()).FirstOrDefault();
    //    var fileInfo = await file.ReadFileInfoAsync();
    //    string extension = Path.GetExtension(fileInfo.Name);
    //    //TODO: Поддерживает jpg и bmp alpha channel
    //    var allowedExtensions = new string[] { ".jpg", ".png", ".bmp" };
    //    if (!allowedExtensions.Contains(extension))
    //    {
    //        message = "Выбранный файл не поддерживается";
    //        messageType = Models.AlertMessageType.Error;
    //        return;
    //        //Файл не подходит
    //    }
    //    message = null;
    //    using (var memoryStream = await file.CreateMemoryStreamAsync())
    //    {
    //        fileStream = new MemoryStream(memoryStream.ToArray());
    //        //TODO: Может сделать настройки где задается ограничение размера и вообще нужно сделать пункт в меню для настроек ???
    //        fileName = fileInfo.Name;
    //        imageContent = $"data:{fileInfo.Type};base64, {Convert.ToBase64String(memoryStream.ToArray())}";
    //    }
    //}

    //async Task getProductTypeAsync()
    //{
    //    var result = await productTypesService.GetProductTypesAsync();
    //    productTypes = result.Records.ToList();
    //}


    async Task addProductTypeAsync()
    {
        var userState = authenticationState.Result;
        string userId = userState.User.FindFirst(ClaimTypes.NameIdentifier).Value;
        //var id = userState.User.FindFirst("Id").Value;
        model.EditedUser = userId;
        productTypesService.AccessToken = userState.User.FindFirst("AccessToken").Value;
        var result = await productTypesService.AddProductTypeAsync(model);
        if(result.IsSuccess)
        {
            message = result.Message;
            messageType = Models.AlertMessageType.Success;
        }
        else
        {
            message = result.Message;
            messageType = Models.AlertMessageType.Error;
        }
    } 
     

    //async Task postProductAsync()
    //{
    //    var userState = authenticationState.Result;
    //    isBusy = true;
    //    model.CoverFile = fileStream;
    //    model.FileName = fileName;
    //    //model.EditedUser = userState.User.FindFirst("Id").Value;
    //    productsService.AccessToken = userState.User.FindFirst("AccessToken").Value;
    //    if (Validate())
    //    {
    //        var result = await productsService.PostProductAsync(model);
    //        if (result.IsSuccess)
    //            navigatorManager.NavigateTo("/Products");
    //        else
    //        {
    //            message = result.Message;
    //            messageType = Models.AlertMessageType.Error;
    //        }
    //    }
    //    isBusy = false;

    //}

    void OnChange(object value)
    {
        @*//TODO: Сделать проверку на стороне сервера на нулевые значения полей возможно добавить атрибут запрещающий сохранять пустые значения*@
        //model.ProductType = (int)value;
    }

    private void CloseInfoMessage()
    {
        message = String.Empty;
    }

    bool Validate()
    {

        //if (model.CoverFile == null)
        //{
        //    messageType = Models.AlertMessageType.Warning;
        //    message = "Файл не выбран";
        //    return false;
        //}
        //if (String.IsNullOrEmpty(model.Description))
        //{
        //    messageType = Models.AlertMessageType.Warning;
        //    message = "Создайте описание";
        //    return false;
        //}
        //if (String.IsNullOrEmpty(model.Name))
        //{
        //    messageType = Models.AlertMessageType.Warning;
        //    message = "Укажите название";
        //    return false;
        //}
        //if (model.ProductType == null)
        //{
        //    messageType = Models.AlertMessageType.Warning;
        //    message = "Выберите тип продукта";
        //    return false;
        //}
        //if (model.Price == 0)
        //{
        //    messageType = Models.AlertMessageType.Warning;
        //    message = "Цена не может быть 0";
        //    return false;
        //}
        return true;
    }

}
